# Github Snake Game

public/GithubSnakeGame.txt  <----- You are here

public/snakeBG.png
       
EmojioneV1Snake.jsx
          
Add Rumble to tailwind.config.js
          
animation: {rumble: 'rumble 0.4s ease-in-out' },



--------------------------------
 // GithubSnakeGame.tsx
--------------------------------
 


import React, { useState, useEffect, useRef } from 'react';
import EmojioneV1Snake from './EmojioneV1Snake';

interface Coordinate {
  x: number;
  y: number;
}

const GRID_SIZE = 20;
const SNAKE_START: Coordinate[] = [{ x: 8, y: 8 }];
const FOOD_START: Coordinate = { x: 12, y: 12 };
const GAME_SPEED = 150;

const FOOD_COLORS = ['#F43F5E', '#F59E0B', '#3B82F6', '#10B981', '#8B5CF6'];

const useInterval = (callback: () => void, delay: number | null) => {
  const savedCallback = useRef(callback);

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    if (delay === null) return;
    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay]);
};

const GithubSnakeGame: React.FC = () => {
  const [snake, setSnake] = useState<Coordinate[]>(SNAKE_START);
  const [food, setFood] = useState<Coordinate>(FOOD_START);
  const [direction, setDirection] = useState<'UP' | 'DOWN' | 'LEFT' | 'RIGHT'>('RIGHT');
  const [gameOver, setGameOver] = useState(false);
  const [score, setScore] = useState(0);
  const [speed, setSpeed] = useState(GAME_SPEED);
  const [flashSegments, setFlashSegments] = useState<boolean[]>([]);
  const [foodColorIndex, setFoodColorIndex] = useState(0);
  const gameCanvas = useRef<HTMLCanvasElement>(null);
  const touchStartRef = useRef<Coordinate | null>(null);
  const [showCode, setShowCode] = useState(false);
  const [codeText, setCodeText] = useState('');

  const handleShowCode = () => {
    fetch('/GithubSnakeGame.txt')
      .then((res) => res.text())
      .then((text) => setCodeText(text))
      .catch(() => setCodeText('// Failed to load code.'));
    setShowCode(true);
  };

  const moveSnake = () => {
    const head = { ...snake[0] };
    switch (direction) {
      case 'UP': head.y -= 1; break;
      case 'DOWN': head.y += 1; break;
      case 'LEFT': head.x -= 1; break;
      case 'RIGHT': head.x += 1; break;
    }

    if (
      head.x < 0 ||
      head.y < 0 ||
      head.x * GRID_SIZE >= (gameCanvas.current?.width ?? 0) ||
      head.y * GRID_SIZE >= (gameCanvas.current?.height ?? 0)
    ) {
      setGameOver(true);
      return;
    }

    if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      setGameOver(true);
      return;
    }

    const newSnake = [head, ...snake];
    if (head.x === food.x && head.y === food.y) {
      const newScore = score + 1;
      setScore(newScore);

      if (newScore % 3 === 0) {
        triggerFlash(newSnake.length);
        setFoodColorIndex((prev) => (prev + 1) % FOOD_COLORS.length);
      }

      setFood(generateFood());
      setSpeed((prev) => Math.max(prev - 5, 50));
    } else {
      newSnake.pop();
    }

    setSnake(newSnake);
  };

  const triggerFlash = (length: number) => {
    setFlashSegments(Array(length).fill(true));
    setTimeout(() => setFlashSegments([]), 300);
  };

  const generateFood = (): Coordinate => {
    let newFood: Coordinate;
    do {
      newFood = {
        x: Math.floor(Math.random() * ((gameCanvas.current?.width ?? 0) / GRID_SIZE)),
        y: Math.floor(Math.random() * ((gameCanvas.current?.height ?? 0) / GRID_SIZE)),
      };
    } while (snake.some(seg => seg.x === newFood.x && seg.y === newFood.y));
    return newFood;
  };

  const startGame = () => {
    setSnake(SNAKE_START);
    setFood(generateFood());
    setDirection('RIGHT');
    setGameOver(false);
    setScore(0);
    setSpeed(GAME_SPEED);
    setFlashSegments([]);
    setFoodColorIndex(0);
  };

  useInterval(moveSnake, gameOver ? null : speed);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
      switch (e.key.toLowerCase()) {
        case 'arrowup': case 'w': if (direction !== 'DOWN') setDirection('UP'); break;
        case 'arrowdown': case 's': if (direction !== 'UP') setDirection('DOWN'); break;
        case 'arrowleft': case 'a': if (direction !== 'RIGHT') setDirection('LEFT'); break;
        case 'arrowright': case 'd': if (direction !== 'LEFT') setDirection('RIGHT'); break;
      }
    };
    window.addEventListener('keydown', handleKeyDown, { passive: false });
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [direction]);

  useEffect(() => {
    const canvas = gameCanvas.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx || !canvas) return;

    const width = canvas.width;
    const height = canvas.height;

    const bgImage = new Image();
    bgImage.src = '/snakeBG.png';

    bgImage.onload = () => {
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(bgImage, 0, 0, width, height);

      snake.forEach((seg, i) => {
        ctx.fillStyle = flashSegments[i]
          ? '#FFEB3B'
          : i === 0 ? '#6EE7B7' : '#34D399';
        ctx.fillRect(seg.x * GRID_SIZE, seg.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        ctx.strokeStyle = '#065F46';
        ctx.strokeRect(seg.x * GRID_SIZE, seg.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
      });

      ctx.fillStyle = FOOD_COLORS[foodColorIndex];
      ctx.fillRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
    };
  }, [snake, food, flashSegments, foodColorIndex]);

  useEffect(() => {
    const canvas = gameCanvas.current;
    if (!canvas) return;

    const handleTouchStart = (e: TouchEvent) => {
      const t = e.touches[0];
      touchStartRef.current = { x: t.clientX, y: t.clientY };
    };
    const handleTouchMove = (e: TouchEvent) => e.preventDefault();
    const handleTouchEnd = (e: TouchEvent) => {
      if (!touchStartRef.current) return;
      const t = e.changedTouches[0];
      const diffX = touchStartRef.current.x - t.clientX;
      const diffY = touchStartRef.current.y - t.clientY;

      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0 && direction !== 'RIGHT') setDirection('LEFT');
        else if (diffX < 0 && direction !== 'LEFT') setDirection('RIGHT');
      } else {
        if (diffY > 0 && direction !== 'DOWN') setDirection('UP');
        else if (diffY < 0 && direction !== 'UP') setDirection('DOWN');
      }
      touchStartRef.current = null;
    };

    canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () => {
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEnd);
    };
  }, [direction]);

  return (
    <div className="relative perspective-1000 w-full max-w-lg mx-auto">
      <div className={`transition-transform duration-700 transform-style-preserve-3d ${showCode ? 'rotate-y-180' : ''} relative w-full h-[540px]`}>

        {/* Front */}
        <div className="card shadow-lg compact bg-base-100 backface-hidden absolute w-full h-full">
          <div className="card-body flex flex-col items-center">
            <div className="bg-white border border-base-300 rounded-lg p-4 w-full flex flex-col items-center">
              <div className="w-full flex justify-between mb-2 items-center">
                <EmojioneV1Snake className="h-6 w-24" />GithubSnakeGame.tsx
                <span className="text-sm font-medium text-indigo-400">ðŸŸ¥ {score}</span>
                <button
                  className="bg-green-700 hover:bg-indigo-600 text-white text-sm font-bold px-3 py-1 rounded"
                  onClick={startGame}
                >
                  {gameOver ? 'Restart' : 'Start'}
                </button>
              </div>
          <canvas
            ref={gameCanvas}
            width={400}
            height={400}
            className={`bg-gray-200 border border-gray-400 rounded-sm ${gameOver ? 'rumble' : ''}`}
            style={{ touchAction: 'none' }}
          />

              {gameOver && (
                <div className="mt-3 text-red-600 font-bold text-base">Game Over!</div>
              )}
              <button
                className="mt-3 bg-indigo-600 text-white px-3 py-1 text-xs rounded hover:bg-blue-700"
                onClick={handleShowCode}
              >
                view component
              </button>
            </div>
            <div className="text-xs text-base-content opacity-40 mt-3">
              W A S D on Keyboard to move the snake
            </div>
            <div className="text-xs text-base-content opacity-40 mt-1">
              GithubSnakeGame.tsx
            </div>
          </div>
        </div>

        {/* Back */}
        <div className="card bg-black text-gray-400 p-4 backface-hidden rotate-y-180 absolute w-full h-full overflow-auto">
          <div className="text-xs font-mono whitespace-pre-wrap overflow-auto max-h-[400px]">
            {codeText || '// Loading...'}
          </div>
          <button
            className="mt-4 bg-indigo-500 text-white px-3 py-1 text-xs rounded hover:bg-green-700"
            onClick={() => setShowCode(false)}
          >
            Back to Game
          </button>
        </div>

      </div>
    </div>
  );
};

export default GithubSnakeGame;

--------------------------------------
  Â¯\_(ãƒ„)_/Â¯  sudo-self.com





